{
  "paperAnswers": [
    { "answer": ["<p>应用版</p>"], "paperQuestionId": 131455 },
    {
      "answer": [
        "<p>可由一个或多个其值能唯一标识该关系模式中任何元组的属性组成</p>"
      ],
      "paperQuestionId": 131440
    },
    { "answer": ["<p>层次</p>"], "paperQuestionId": 131444 },
    { "answer": ["<p>一对一关系</p>"], "paperQuestionId": 131437 },
    {
      "answer": ["<p>任何一张二维表都表示一个关系</p>"],
      "paperQuestionId": 131450
    },
    {
      "answer": [
        "<p>系统存储过程</p>",
        "<p>用户自定义存储过程</p>",
        "<p>扩展存储过程</p>"
      ],
      "paperQuestionId": 131535
    },
    {
      "answer": ["<p>层次</p>", "<p>网状</p>", "<p>关系</p>"],
      "paperQuestionId": 131526
    },
    {
      "answer": ["<p>工作组版</p>", "<p>开发版</p>"],
      "paperQuestionId": 131524
    },
    {
      "answer": ["<p>视图机制</p>", "<p>授权子系统</p>"],
      "paperQuestionId": 131562
    },
    {
      "answer": ["<p>实体完整性</p>", "<p>语义完整性</p>", "<p>引用完整性</p>"],
      "paperQuestionId": 131525
    },
    { "answer": ["对"], "paperQuestionId": 131700 },
    { "answer": ["对"], "paperQuestionId": 131714 },
    { "answer": ["错"], "paperQuestionId": 131721 },
    { "answer": ["对"], "paperQuestionId": 131688 },
    { "answer": ["错"], "paperQuestionId": 131715 },
    { "answer": ["对"], "paperQuestionId": 131691 },
    { "answer": ["对"], "paperQuestionId": 131708 },
    { "answer": ["对"], "paperQuestionId": 131711 },
    { "answer": ["错"], "paperQuestionId": 131683 },
    { "answer": ["对"], "paperQuestionId": 131731 },
    { "answer": ["<p>逻辑设计</p>"], "paperQuestionId": 131639 },
    { "answer": ["<p>外模式/模式映像</p>"], "paperQuestionId": 131604 },
    { "answer": ["<p>外键或外码或外部关键字</p>"], "paperQuestionId": 131627 },
    { "answer": ["<p>关系</p>"], "paperQuestionId": 131626 },
    { "answer": ["<p>πA,D(σE='80'(RS))</p>"], "paperQuestionId": 131612 },
    {
      "answer": [
        "<p>基本表：基本表是本身独立存在的表，是数据库中真是存在且存储数据的独立的表；</p><p>视图：是数据库中虚拟的表，是从一个或几个基本表导出的表。它本身不独立存储在数据库中，并不真实存储数据，只存储数据的定义；</p><p><br></p><p>区别：</p><ol><li>视图是已经编译好的sql语句。而表不是</li><li>视图没有实际的物理记录。而表有。</li><li>表是内容，视图是窗口</li><li>表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</li><li>表是内模式，试图是外模式</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</li><li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ol><p><br></p><p>联系：</p><p>视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表；如果基本表中的数据发生了变化，对应的视图查询结果也会随之变化 。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>"
      ],
      "paperQuestionId": 131741
    },
    {
      "answer": [
        "<p>死锁是指多个进程或线程在等待相互持有的资源时，形成一种互相等待的状态，如果不加干预,则会一起等待下去，导致所有进程或线程都无法继续执行的情况，从而产牛死锁。主要原因通常有以下几个方面：</p><ol><li>竞争资源：多个进程或线程同时竞争同一资源，如数据库表、文件、内存等。</li><li>持有锁不释放：进程或线程获取了某个资源的锁，但是在使用完之后没有及时释放锁。</li><li>循环等待：多个进程或线程之间形成了一种循环等待的状态，每个进程或线程都在等待其他进程或线程所持有的资源。</li></ol><p>预防死锁的三种方法：</p><ol><li>优化资源竞争：通过合理的资源分配和使用，减少进程或线程之间竞争同一资源的情况，如使用粒度更小的锁、避免长时间占用资源等。</li><li>避免持有和等待：进程或线程在请求资源时，应该一次性请求所有需要的资源，而不是分散地进行请求，从而避免持有和等待的情况。</li><li>避免循环等待：通过对资源进行编号或排序，使得进程或线程按照相同的顺序请求资源，避免形成循环等待的状态，或者使用超时机制强制释放资源，打破循环等待的状态。</li></ol><p>总之，死锁是一种常见的并发编程问题，在开发中需要注意避免和预防。预防死锁的方法包括优化资源竞争、避免持有和等待、避免循环等待等。</p>"
      ],
      "paperQuestionId": 131901
    }
  ],
  "paperId": 2147553365,
  "paperStartTime": "2023-07-04 21:20:26",
  "studentId": "39270",
  "examId": 2141353807,
  "remark": 2,
  "id": 2145886999
}
